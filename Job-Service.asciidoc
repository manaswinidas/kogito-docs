# Kogito Job Service

## Overview

Kogito Job Service is a dedicated lightweight service responsible for scheduling jobs that aim to be fired at a given time. The service does not execute the job itself, it triggers a callback that could be an HTTP request on a given endpoint specified on the job request, or any other callback that could be supported by the service.

## Architecture

image::images/Job Service Architecture.png[Job Service - Architecture]


Basically, the Job Service receives requests of job scheduling and it sends a request at the time specified on the job request, as shown above.

The main goal of the service is to work with only active jobs, in this way it only keeps track of the jobs that are scheduled and supposed to be executed, the jobs that achieve a final state are removed from the job service. It is important to notice that all job information and transitioning states are pushed to Kogito Data Index where they can be indexed and made available for queries.

## Technical Overview

The Job Service implementation is based on non-blocking APIs and reactive messaging on the top of Quarkus, which provides the most effective throughput and resource utilization. The current scheduling engine is implemented on the top of Vert.x and the external requests are built using a non-blocking HTTP client based on Vert.x.


### Stack

* https://quarkus.io/[*Quarkus]*
* https://vertx.io/[*Vert.x]*
* https://smallrye.io/smallrye-reactive-messaging/[*Reactive Messaging]*
* https://infinispan.org/[*Infinispan]*

### State control

Job service uses an internal state control to manage the job scheduling lifecycle that is detailed on the following diagram:

image::images/Job Service - States.png[Job Service - States]


### Job types

Current these are the supported Job types that can be executed by the Job Service.

#### Date scheduled

#### Periodic scheduled

### Supported callbacks

#### HTTP

HTTP POST requests that are sent do a given endpoint specified on the job scheduling request.

### Persistence

#### In-Memory

#### Infinispan

* Configuration

### API documentation

The current API documentation is based on Swagger, and the service has an embedded UI available at
http://localhost:8080/swagger-ui/[*http://localhost:8080/swagger-ui]*

## Getting started


* *Build*

* *Run*

----
mvn clean compile quarkus:dev
----

* *Running with Infinispan persistence*

* *Schedule a Job*

* *Reschedule a Job*

* *Cancel a scheduled Job*

* *Retrieve a scheduled Job*


# Kogito Job Service add-ons

Addons are specific classes that provides integration with Kogito Job Service to the runtime services. This allows to use Job Service as a timer service for process instances. Whenever there is a need to schedule timer as part of process instance it will be scheduled in the Job Service and the job service will callback the service upon timer expiration.

The general implementation of the add-on is as follows:

* an implementation of `org.kie.kogito.jobs.JobsService` interface that is used by the service to schedule jobs
* REST endpoint registered on `/management/jobs` path

## Configuration properties

Regardless of the runtime being used following are two configuration properties that are expected (and by that are mandatory)

[cols="40%,400%,20%"]
|===
|Name |Description |Example 

|`kogito.service.url`
|A URL that identifies where the service is deployed to. Used by runtime events to set the source of the event.
|http://localhost:8080

|`kogito.jobs-service.url`
|An URL that posts to a running Kogito Job Service, it is expected to be in form `scheme://host:port`
|http://localhost:8085
|===

## JobService implementation

A dedicated `org.kie.kogito.jobs.JobsService` implementation is provided based on the runtime being used (either Quarkus or SpringBoot) as it relies on the technology used in these runtime to optimise dependencies and integration. 

### Quarkus 

For Quarkus based runtimes, there is `org.kie.kogito.jobs.management.quarkus.VertxJobsService` implementation that utilises Vert.x `WebClient` to interact with Job Service over HTTP.

It configures web client by default based on properties found in application.properties. Though in case this is not enough it supports to provide custom instance of `io.vertx.ext.web.client.WebClient` type that will be used instead to communicate with Job Service.

### Spring Boot

For Spring Boot based runtimes, there is `org.kie.kogito.jobs.management.springboot.SpringRestJobsService` implementation that utilises Spring `RestTemplate` to interact with Job Service over HTTP. 

It configures rest template by default based on properties found in application.properties. Though in case this is not enough it supports to provide custom instance of `org.springframework.web.client.RestTemplate` type that will be used instead to communicate with Job Service.

## REST endpoint for callbacks

The REST endpoint that is provided with the add-on is responsible for receiving the callbacks from Job Service at exact time when the timer was scheduled and by that move the process instance execution forward.

The callback URL is given to the Job Service upon scheduling and as such does provide all the information that are required to move the instance

* process id
* process instance id
* timer instance id

NOTE: Timer instance id is build out of two parts - actual job id (in UUID format) and a timer id (a timer definition id generated by the process engine). An example of a timer instance id is `62cad2e4-d343-46ac-a89c-3e313a30c1ad_1` where `62cad2e4-d343-46ac-a89c-3e313a30c1ad` is the UUID of the job and `1` is the timer definition id. Both values are separated with `_`


